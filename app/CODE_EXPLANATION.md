# Объяснение кода Telegram-бота для заметок

Этот документ содержит построчное объяснение всего кода проекта.

---

## handlers.py

### Импорты (строки 1-35)

**Строка 4:** `from aiogram import F, Router, Bot`
- **F** - фильтр для проверки содержимого сообщений (например, по тексту)
- **Router** - роутер для регистрации обработчиков сообщений и команд
- **Bot** - класс бота для отправки сообщений пользователям

**Строка 10:** `from aiogram.types import Message, CallbackQuery, ReplyKeyboardRemove`
- **Message** - тип обычного текстового сообщения от пользователя
- **CallbackQuery** - тип ответа на нажатие inline-кнопки (импортирован, но не используется)
- **ReplyKeyboardRemove** - класс для удаления клавиатуры (импортирован, но не используется)

**Строка 15:** `from aiogram.filters import CommandStart, Command`
- **CommandStart** - фильтр для команды `/start`
- **Command** - фильтр для других команд (например, `/help`)

**Строка 19:** `from aiogram.fsm.context import FSMContext`
- **FSMContext** - контекст FSM (машины конечных состояний) для управления состояниями диалога
- Позволяет сохранять данные между сообщениями одного пользователя

**Строка 24:** `from aiogram.fsm.state import State, StatesGroup`
- **State** - класс для создания одного состояния диалога
- **StatesGroup** - класс для группировки связанных состояний

**Строка 29:** `from datetime import datetime, timedelta`
- **datetime** - класс для работы с датами и временем
- **timedelta** - класс для вычисления разницы во времени (импортирован, но не используется)

**Строка 32:** `import re`
- Модуль для работы с регулярными выражениями (нужен для парсинга даты и времени)

**Строка 35:** `import app.keyboards as kb`
- Импорт модуля с клавиатурами бота (кнопки для пользователя)
- `as kb` - псевдоним для удобства использования

### Глобальные переменные (строки 39-48)

**Строка 39:** `router = Router()`
- Создание роутера для регистрации обработчиков сообщений
- Роутер позволяет связывать функции с определенными типами сообщений

**Строка 44:** `notes_storage = {}`
- Словарь для хранения заметок всех пользователей
- Структура: `{user_id: [{'id': 1, 'text': '...', 'reminder_time': '...', 'reminder_sent': False}, ...]}`
- Ключ - ID пользователя, значение - список заметок пользователя

**Строка 48:** `bot_instance = None`
- Глобальная переменная для хранения экземпляра бота
- Нужна для отправки напоминаний из фоновой задачи (reminders.py)

### Функции и классы

**Строки 53-57:** Функция `set_bot_instance(bot: Bot)`
- **Строка 53:** Объявление функции с параметром `bot` типа `Bot`
- **Строка 55:** `global bot_instance` - объявление, что используется глобальная переменная
- **Строка 57:** Сохранение переданного бота в глобальную переменную

**Строки 61-69:** Класс `NoteStates(StatesGroup)`
- Класс для определения состояний диалога при работе с заметками
- Наследуется от `StatesGroup` для группировки связанных состояний
- **Строка 63:** `waiting_for_note = State()` - состояние ожидания текста заметки
- **Строка 66:** `waiting_for_note_time = State()` - состояние ожидания времени напоминания
- **Строка 69:** `waiting_for_delete_id = State()` - состояние ожидания номера заметки для удаления

### Обработчики команд

**Строки 74-86:** Функция `cmd_start(message: Message)`
- **Строка 74:** Декоратор `@router.message(CommandStart())` - регистрирует функцию как обработчик команды `/start`
- **Строка 77:** Асинхронная функция обработки команды `/start`
- **Строка 81-85:** Отправка приветственного сообщения пользователю с главной клавиатурой
- `\n\n` - перенос строки (два раза для пустой строки)
- `reply_markup=kb.main` - подключение главной клавиатуры с кнопками

**Строки 91-110:** Функция `cmd_help(message: Message)`
- **Строка 91:** Декоратор для обработки команды `/help`
- **Строка 93:** Асинхронная функция для показа справки
- **Строка 96-108:** Создание многострочной строки со справкой (используются круглые скобки)
- **Строка 110:** Отправка справки пользователю с главной клавиатурой

### Обработчики кнопок

**Строки 115-134:** Функция `add_note_start(message: Message, state: FSMContext)`
- **Строка 115:** Декоратор для обработки нажатия кнопки "Добавить заметку"
- `F.text == 'Добавить заметку'` - фильтр, который срабатывает при точном совпадении текста
- **Строка 118:** Асинхронная функция начала процесса добавления заметки
- **Строка 120:** Получение текущего состояния пользователя
- **Строка 123:** Проверка: если пользователь уже в процессе добавления заметки, отменяем его
- **Строка 125:** Очистка состояния FSM
- **Строка 128-131:** Отправка инструкции пользователю
- **Строка 134:** Установка состояния `waiting_for_note` - теперь следующие сообщения будут обрабатываться функцией `add_note_text`

**Строки 138-203:** Функция `show_notes(message: Message, state: FSMContext)`
- **Строка 138:** Декоратор для обработки нажатия кнопки "Мои заметки"
- **Строка 140:** Асинхронная функция для показа всех заметок пользователя
- **Строка 142:** Получение текущего состояния
- **Строка 144:** Флаг `was_cancelled` - показывает, был ли отменен процесс добавления заметки
- **Строки 147-151:** Если пользователь был в процессе добавления заметки, отменяем его и устанавливаем флаг
- **Строка 155:** Получение ID пользователя из сообщения (`from_user.id` - уникальный идентификатор в Telegram)
- **Строка 160:** Проверка: есть ли у пользователя заметки
- `user_id not in notes_storage` - пользователь еще не создавал заметок
- `len(notes_storage[user_id]) == 0` - у пользователя есть запись, но список пуст
- **Строки 162-166:** Если заметок нет, отправляем соответствующее сообщение
- **Строка 173:** Получение списка заметок пользователя
- **Строка 175:** Начало формирования текста с заметками
- **Строка 177:** Перебор всех заметок пользователя
- **Строка 182:** Формирование строки с номером и текстом заметки (f-строка для подстановки значений)
- **Строка 186:** Проверка: есть ли у заметки напоминание и оно еще не было отправлено
- `note.get('reminder_time')` - безопасное получение значения (вернет None, если ключа нет)
- `not note.get('reminder_sent', False)` - напоминание еще не отправлено
- **Строки 187-199:** Если есть напоминание, пытаемся его отформатировать и добавить к тексту
- **Строка 190:** Преобразование строки времени из ISO формата в объект datetime
- **Строка 193:** Форматирование даты и времени в читаемый вид: '25.12.2024 15:30'
- `%d` - день, `%m` - месяц, `%Y` - год, `%H` - часы, `%M` - минуты
- **Строка 199:** Если произошла ошибка при парсинге, просто пропускаем (pass)
- **Строка 201:** Добавление строки заметки к общему тексту
- **Строка 203:** Отправка сформированного списка заметок пользователю

**Строки 207-258:** Функция `delete_note_start(message: Message, state: FSMContext)`
- **Строка 207:** Декоратор для обработки нажатия кнопки "Удалить заметку"
- **Строка 209:** Асинхронная функция начала процесса удаления заметки
- **Строка 211:** Получение текущего состояния
- **Строки 214-218:** Если пользователь был в процессе добавления заметки, отменяем его
- **Строка 221:** Получение ID пользователя
- **Строка 224:** Проверка: есть ли у пользователя заметки для удаления
- **Строка 226:** Если заметок нет, сообщаем об этом и выходим из функции (return)
- **Строка 230:** Получение списка заметок пользователя
- **Строка 232:** Начало формирования текста со списком заметок
- **Строки 234-250:** Перебор всех заметок для отображения (аналогично функции show_notes)
- **Строка 252:** Добавление инструкции о том, что нужно ввести номер заметки
- **Строка 255:** Отправка списка заметок с инструкцией
- **Строка 258:** Установка состояния `waiting_for_delete_id` - следующее сообщение будет обработано функцией `delete_note_finish`

**Строки 262-290:** Функция `delete_all_notes(message: Message, state: FSMContext)`
- **Строка 262:** Декоратор для обработки нажатия кнопки "Удалить все заметки"
- **Строка 264:** Асинхронная функция для удаления всех заметок пользователя
- **Строки 266-273:** Получение состояния и отмена процесса добавления заметки, если он был запущен
- **Строка 276:** Получение ID пользователя
- **Строка 279:** Проверка: есть ли у пользователя заметки для удаления
- **Строка 285:** Сохранение количества заметок перед удалением (для сообщения пользователю)
- **Строка 287:** Очистка списка заметок пользователя (замена на пустой список)
- **Строка 290:** Отправка сообщения об успешном удалении всех заметок с указанием количества

**Строки 294-308:** Функция `show_help(message: Message, state: FSMContext)`
- **Строка 294:** Декоратор для обработки нажатия кнопки "Помощь"
- **Строка 296:** Асинхронная функция для показа справки
- **Строки 298-305:** Отмена процесса добавления заметки, если он был запущен
- **Строка 308:** Вызов функции `cmd_help` для показа справки (переиспользование кода)

### Обработчики состояний FSM

**Строки 313-364:** Функция `delete_note_finish(message: Message, state: FSMContext)`
- **Строка 313:** Декоратор для обработки сообщений в состоянии `waiting_for_delete_id`
- Фильтр по состоянию FSM (не по тексту сообщения)
- **Строка 315:** Асинхронная функция завершения процесса удаления заметки
- **Строка 317:** Получение ID пользователя
- **Строка 320:** Блок try-except для обработки ошибок
- **Строка 323:** Преобразование текста сообщения в число (номер заметки)
- `int(message.text)` может вызвать ValueError, если текст не является числом
- **Строка 325:** Получение списка заметок пользователя
- **Строка 328:** Флаг `note_found` - показывает, была ли найдена заметка с указанным номером
- **Строка 330:** Перебор заметок с использованием `enumerate` для получения индекса (i) и самой заметки (note)
- **Строка 332:** Проверка: совпадает ли номер заметки с запрошенным для удаления
- **Строка 334:** Сохранение текста удаляемой заметки для сообщения пользователю
- **Строка 337:** Удаление заметки из списка по индексу i (`pop(i)` удаляет элемент и возвращает его)
- **Строка 339:** Установка флага, что заметка найдена и удалена
- **Строки 343-345:** Перенумерация оставшихся заметок после удаления
- `enumerate(notes_list, start=1)` - начинаем нумерацию с 1
- **Строка 348:** Отправка сообщения об успешном удалении с текстом удаленной заметки
- **Строка 350:** Выход из цикла, так как заметка уже найдена и удалена (break)
- **Строки 353-355:** Если заметка не была найдена, сообщаем пользователю
- **Строка 358:** Очистка состояния FSM после завершения процесса удаления
- **Строки 359-364:** Обработка ошибки ValueError (если пользователь ввел не число)

**Строки 369-393:** Функция `add_note_text(message: Message, state: FSMContext)`
- **Строка 369:** Декоратор для обработки сообщений в состоянии `waiting_for_note`
- Эта функция вызывается, когда пользователь находится в состоянии ожидания текста заметки
- **Строка 371:** Асинхронная функция обработки текста заметки от пользователя
- **Строка 374:** Список текстов кнопок главного меню
- Если пользователь нажал кнопку вместо ввода текста, игнорируем это сообщение
- **Строка 376:** Проверка: если текст сообщения совпадает с текстом одной из кнопок
- **Строка 378:** Выход из функции без обработки (кнопки обрабатываются другими обработчиками)
- **Строка 382:** Сохранение текста заметки в данных состояния FSM
- `update_data` - обновление данных состояния (сохраняет note_text для использования в следующем состоянии)
- **Строка 384-390:** Отправка сообщения с инструкцией о следующем шаге (установка времени напоминания)
- **Строка 393:** Установка следующего состояния: `waiting_for_note_time`
- Теперь следующее сообщение будет обрабатываться функцией `add_note_time`

**Строки 398-490:** Функция `add_note_time(message: Message, state: FSMContext)`
- **Строка 398:** Декоратор для обработки сообщений в состоянии `waiting_for_note_time`
- **Строка 400:** Асинхронная функция обработки времени напоминания и сохранения заметки
- **Строки 403-407:** Игнорирование нажатий кнопок (аналогично add_note_text)
- **Строка 410:** Получение ID пользователя
- **Строка 412:** Получение всех данных из состояния FSM (включая сохраненный ранее текст заметки)
- **Строка 415:** Извлечение текста заметки из данных состояния
- `get('note_text')` - безопасное получение значения (вернет None, если ключа нет)
- **Строка 418:** Проверка: есть ли у пользователя запись в хранилище заметок
- **Строка 420:** Если записи нет, создаем пустой список заметок для этого пользователя
- **Строка 423:** Инициализация переменной для времени напоминания (по умолчанию None)
- **Строка 428:** Проверка: хочет ли пользователь пропустить установку напоминания
- `message.text.lower()` - преобразование текста в нижний регистр для сравнения
- Проверка на несколько вариантов отказа: 'пропустить', 'нет', 'без напоминания'
- **Строка 430:** Установка None, что означает отсутствие напоминания
- **Строка 433:** Попытка распарсить введенное время
- **Строка 436:** Вызов функции `parse_datetime` для преобразования строки в объект datetime
- Может вызвать ValueError, если формат неверный
- **Строка 440:** Проверка: время напоминания должно быть в будущем
- `datetime.now()` - текущее время
- `<=` означает "меньше или равно", то есть если время в прошлом или настоящем
- **Строки 442-447:** Если время в прошлом, отправляем сообщение об ошибке и выходим из функции
- **Строки 448-458:** Обработка ошибки ValueError (если формат времени неверный)
- **Строка 461:** Вычисление ID новой заметки (количество существующих заметок + 1)
- **Строки 464-472:** Добавление новой заметки в список заметок пользователя
- Структура заметки: словарь с полями id, text, reminder_time, reminder_sent
- `reminder_time.isoformat()` - преобразует datetime в строку формата '2024-12-25T15:30:00'
- Тернарный оператор: если reminder_time не None, преобразуем в ISO, иначе None
- **Строка 475:** Проверка: было ли установлено время напоминания
- **Строка 477:** Форматирование времени напоминания в читаемый вид для сообщения
- **Строки 479-483:** Отправка сообщения об успешном сохранении заметки с информацией о напоминании
- **Строки 485-486:** Если напоминание не установлено, отправка сообщения без информации о времени
- **Строка 490:** Очистка состояния FSM после успешного сохранения заметки

### Функция парсинга даты

**Строки 495-536:** Функция `parse_datetime(date_string)`
- **Строка 495:** Функция для парсинга строки с датой и временем в объект datetime
- Параметр `date_string` - строка с датой и временем (например: "25.12.2024 15:30")
- **Строки 506-509:** Список регулярных выражений (паттернов) для различных форматов ввода даты
- `r'...'` - raw string (сырая строка), где обратный слэш не экранирует символы
- `(\d{1,2})` - группа из 1-2 цифр (день или месяц)
- `\.` - точка (экранированная, так как точка в regex означает "любой символ")
- `(\d{4})` - группа из 4 цифр (год)
- `\s+` - один или несколько пробелов
- `(\d{1,2})` - часы (1-2 цифры)
- `:` - двоеточие
- `(\d{2})` - минуты (ровно 2 цифры)
- Второй паттерн включает секунды: `(\d{2})` - секунды (ровно 2 цифры)
- **Строка 512:** Перебор всех паттернов для проверки соответствия
- **Строка 516:** Попытка сопоставить строку с регулярным выражением
- `date_string.strip()` - удаление пробелов в начале и конце строки
- `re.match()` - проверяет совпадение с начала строки
- **Строка 518:** Если совпадение найдено
- **Строка 521:** Получение всех групп (частей строки, соответствующих скобкам в regex)
- `groups()` возвращает кортеж: ('25', '12', '2024', '15', '30') для первого паттерна
- **Строка 525:** Извлечение и преобразование значений даты в числа
- `groups[0]` - день, `groups[1]` - месяц, `groups[2]` - год
- `int()` - преобразование строки в целое число
- **Строка 528:** Извлечение и преобразование значений времени в числа
- `groups[3]` - часы, `groups[4]` - минуты
- **Строка 532:** Создание и возврат объекта datetime из извлеченных значений
- `datetime(year, month, day, hour, minute)` - конструктор datetime
- **Строка 536:** Если ни один паттерн не подошел, выбрасываем исключение ValueError

---

## keyboards.py

**Строка 6:** `from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton`
- **ReplyKeyboardMarkup** - класс для создания постоянной клавиатуры (всегда видна внизу экрана)
- **KeyboardButton** - класс для создания кнопки в постоянной клавиатуре
- **InlineKeyboardMarkup** - класс для создания inline-клавиатуры (кнопки под конкретным сообщением, не используется)
- **InlineKeyboardButton** - класс для создания кнопки в inline-клавиатуре (не используется)

**Строки 10-29:** Переменная `main = ReplyKeyboardMarkup(...)`
- Создание главной клавиатуры бота
- **Строка 13:** `keyboard` - список строк, каждая строка - это список кнопок в одном ряду
- Каждый элемент списка - список кнопок (KeyboardButton), которые будут в одном ряду
- **Строка 16:** Первый ряд клавиатуры: одна кнопка "Добавить заметку"
- `[KeyboardButton(...)]` - список с одной кнопкой (один ряд)
- **Строка 19:** Второй ряд клавиатуры: две кнопки рядом друг с другом
- `[KeyboardButton(...), KeyboardButton(...)]` - список с двумя кнопками (один ряд)
- **Строка 21:** Третий ряд клавиатуры: две кнопки рядом друг с другом
- **Строка 25:** `resize_keyboard=True` - автоматическое изменение размера кнопок для компактности
- Кнопки будут подстраиваться под размер экрана устройства
- **Строка 28:** `input_field_placeholder='Выберите действие'` - текст-подсказка, который показывается в поле ввода сообщения
- Помогает пользователю понять, что нужно выбрать действие из клавиатуры

---

## reminders.py

**Строка 2:** `from datetime import datetime`
- Импорт класса datetime для работы с датой и временем

**Строка 5:** `from aiogram import Bot`
- Импорт класса Bot для отправки сообщений пользователям

**Строка 9:** `import asyncio`
- Импорт модуля asyncio для асинхронного программирования
- Нужен для создания фоновой задачи проверки напоминаний и задержек

**Строка 14:** `notes_storage = None`
- Глобальная переменная для хранения хранилища заметок всех пользователей
- Будет установлена функцией `start_reminder_checker`
- Изначально None, так как хранилище находится в другом модуле (handlers.py)

**Строка 19:** `bot_instance = None`
- Глобальная переменная для хранения экземпляра бота
- Нужна для отправки напоминаний пользователям
- Будет установлена функцией `start_reminder_checker`

**Строки 24-83:** Функция `check_reminders()`
- Асинхронная функция для проверки напоминаний
- Работает в бесконечном цикле, периодически проверяя, не наступило ли время напоминаний
- **Строка 26:** `while True:` - бесконечный цикл для постоянной проверки напоминаний
- **Строка 28:** Блок try-except для обработки любых ошибок в процессе проверки
- **Строка 31:** Проверка: инициализированы ли хранилище заметок и экземпляр бота
- Если оба не None, значит можно проверять напоминания
- **Строка 33:** Получение текущего времени для сравнения с временем напоминаний
- **Строка 37:** Перебор всех пользователей в хранилище
- `items()` возвращает пары (ключ, значение): (user_id, список_заметок)
- **Строка 39:** Перебор всех заметок конкретного пользователя
- **Строка 43:** Проверка: есть ли у заметки время напоминания и оно еще не было отправлено
- `note.get('reminder_time')` - безопасное получение времени напоминания
- `not note.get('reminder_sent', False)` - напоминание еще не отправлено
- **Строка 45:** Блок try-except для обработки ошибок при работе с конкретным напоминанием
- **Строка 48:** Преобразование строки времени из ISO формата в объект datetime
- ISO формат: '2024-12-25T15:30:00'
- **Строка 52:** Проверка: наступило ли время напоминания
- `current_time >= reminder_time` означает, что текущее время больше или равно времени напоминания
- **Строки 57-60:** Отправка напоминания пользователю через бота
- `send_message(chat_id, text)` - метод для отправки сообщения
- `user_id` - ID пользователя (chat_id)
- `f'...'` - f-строка с текстом напоминания, включая текст заметки
- **Строка 63:** Установка флага, что напоминание было отправлено
- Это предотвращает повторную отправку того же напоминания
- **Строка 64:** Обработка ошибок при отправке конкретного напоминания
- **Строка 68:** Вывод ошибки в консоль для отладки
- **Строка 73:** Задержка 10 секунд перед следующей проверкой напоминаний
- `sleep()` - приостановка выполнения функции на указанное время
- `await` - ожидание завершения задержки (не блокирует другие задачи)
- **Строка 77:** Если хранилище или бот еще не инициализированы, ждем меньше времени (5 секунд)
- и проверяем снова (чтобы быстрее начать проверку после инициализации)
- **Строка 81:** Обработка любых других ошибок в функции check_reminders
- **Строка 83:** Задержка 5 секунд перед следующей попыткой (чтобы не зациклиться на ошибке)

**Строки 90-101:** Функция `start_reminder_checker(storage, bot)`
- Функция для запуска фоновой задачи проверки напоминаний
- Параметры:
  - `storage` - ссылка на хранилище заметок из handlers.py
  - `bot` - экземпляр бота для отправки сообщений
- **Строка 92:** `global notes_storage, bot_instance` - объявление, что используются глобальные переменные
- **Строка 94:** Сохранение ссылки на хранилище заметок в глобальную переменную
- **Строка 96:** Сохранение экземпляра бота в глобальную переменную
- **Строка 101:** Создание и запуск фоновой задачи (coroutine)
- `create_task()` - создает задачу, которая будет выполняться параллельно с основной программой
- `check_reminders()` - функция, которая будет выполняться в фоне
- Задача запускается сразу и работает независимо от основного потока программы

---

## Итоговая структура проекта

1. **handlers.py** - содержит все обработчики команд и сообщений, логику работы с заметками
2. **keyboards.py** - содержит определение клавиатуры бота
3. **reminders.py** - содержит фоновую задачу для проверки и отправки напоминаний

Все файлы работают вместе для создания полнофункционального Telegram-бота для управления заметками с возможностью установки напоминаний.

